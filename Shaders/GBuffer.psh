#include "HLSL_Structures.hlsli"

// Constant Buffers
cbuffer MATERIAL_CONSTANTS
{
    // BaseColor/Opacity
    float4 g_BaseColorFactor; // rgb = base color, a = opacity

    // Emissive
    float3 g_EmissiveFactor; // emissive rgb
    float g_EmissiveIntensity; // scalar

    // PBR factors
    float g_RoughnessFactor; // scalar
    float g_NormalScale; // scalar
    float g_OcclusionStrength; // scalar
    float g_AlphaCutoff; // scalar (for MASK)

    float g_MetallicFactor; // scalar
    uint g_MaterialFlags; // bitmask HAS_*
    uint2 _pad0; // 16-byte align
}

// Resources
Texture2D g_BaseColorTex;
Texture2D g_NormalTex;
Texture2D g_MetallicRoughnessTex;
Texture2D g_AOTex;
Texture2D g_EmissiveTex;
Texture2D g_HeightTex;

SamplerState g_LinearWrapSampler;

// Input / Output
struct PSInput
{
    float4 Pos : SV_POSITION;
    float2 UV : TEXCOORD0;
    float3 WorldPos : TEXCOORD1;
    float3 WorldN : TEXCOORD2;
    float3 WorldT : TEXCOORD3;

    bool bFrontFace : SV_IsFrontFace;
};

struct PSOutput
{
    // GBuffer0: Albedo.rgb, Opacity.a
    float4 GBuffer0 : SV_TARGET0;

    // GBuffer1: Normal.xyz packed (0..1), unused or normal strength in w
    float4 GBuffer1 : SV_TARGET1;

    // GBuffer2: Metallic, Roughness, AO, MaterialId(or Flags/Spec) in a
    float4 GBuffer2 : SV_TARGET2;

    // GBuffer3: Emissive.rgb, unused in a
    float4 GBuffer3 : SV_TARGET3;
};

// ----------------------------------------------------------------------------
// Helpers
// ----------------------------------------------------------------------------
float3 UnpackNormalTS(float3 n01)
{
    return normalize(n01 * 2.0 - 1.0);
}

float3 PackNormal01(float3 n)
{
    return n * 0.5 + 0.5;
}

// Returns pseudo-random in [0,1)
float Hash2D(float2 p)
{
    float v = 1.0e4 * sin(17.0 * p.x + 0.1 * p.y) * 0.1 + abs(sin(13.0 * p.y + p.x));
    return frac(v);
}

float DitherThreshold(float4 svPos)
{
    float2 ip = floor(svPos.xy);
    return Hash2D(ip);
}

void AlphaDitherTest(float alpha, float4 svPos)
{
    float r = DitherThreshold(svPos);
    if (alpha < r)
    {
        discard;
    }
}

// ----------------------------------------------------------------------------
// Main
// ----------------------------------------------------------------------------
void main(in PSInput IN, out PSOutput OUT)
{
    float2 uv = IN.UV;

    // BaseColor / Opacity
    float4 baseColor = g_BaseColorFactor;
    if ((g_MaterialFlags & MAT_HAS_BASECOLOR) != 0)
    {
        baseColor *= g_BaseColorTex.Sample(g_LinearWrapSampler, uv);
    }

    // Alpha cutout (MASK)
    AlphaDitherTest(baseColor.a * g_BaseColorFactor.a, IN.Pos);

    // Metallic / Roughness
    float metallic = g_MetallicFactor;
    float roughness = g_RoughnessFactor;

    if ((g_MaterialFlags & MAT_HAS_MR) != 0)
    {
        float4 mr = g_MetallicRoughnessTex.Sample(g_LinearWrapSampler, uv);

        // glTF convention: B = metallic, G = roughness
        metallic *= mr.b;
        roughness *= mr.g;
    }

    metallic = saturate(metallic);
    roughness = saturate(roughness);

    // AO
    float ao = 1.0;
    if ((g_MaterialFlags & MAT_HAS_AO) != 0)
    {
        ao = g_AOTex.Sample(g_LinearWrapSampler, uv).r;
        ao = lerp(1.0, ao, g_OcclusionStrength);
    }

    // Emissive
    float3 emissive = g_EmissiveFactor;
    if ((g_MaterialFlags & MAT_HAS_EMISSIVE) != 0)
    {
        emissive *= g_EmissiveTex.Sample(g_LinearWrapSampler, uv).rgb;
    }
    emissive *= g_EmissiveIntensity;

    // Normal (World Space) + flip
    float3 N = normalize(IN.WorldN);

    bool bFlipNormal = !IN.bFrontFace;
    if (bFlipNormal)
    {
        N = -N;
    }

    if ((g_MaterialFlags & MAT_HAS_NORMAL) != 0)
    {
        float3 T = normalize(IN.WorldT);
        float3 B = normalize(cross(N, T));

        float3 nTS = UnpackNormalTS(g_NormalTex.Sample(g_LinearWrapSampler, uv).xyz);
        nTS.xy *= g_NormalScale;

        // Keep normal map consistent on backfaces for two-sided shading
        if (bFlipNormal)
        {
            nTS.xy = -nTS.xy;
        }

        float3x3 TBN = float3x3(T, B, N);
        N = normalize(mul(nTS, TBN));
    }

    // Pack to GBuffer
    OUT.GBuffer0 = float4(baseColor.rgb, baseColor.a);
    OUT.GBuffer1 = float4(PackNormal01(N), 1.0);
    OUT.GBuffer2 = float4(metallic, roughness, ao, 0.0);
    OUT.GBuffer3 = float4(emissive, 1.0);
}
