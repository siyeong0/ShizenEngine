#include "HLSL_Structures.hlsli"

cbuffer MATERIAL_CONSTANTS
{
    float4 g_BaseColorFactor; // rgb = base color, a = opacity
    float3 g_EmissiveFactor; // emissive rgb
    float g_EmissiveIntensity; // scalar

    float g_RoughnessFactor; // scalar
    float g_NormalScale; // scalar
    float g_OcclusionStrength; // scalar
    float g_AlphaCutoff; // scalar (for MASK)

    float g_MetallicFactor; // scalar
    uint g_MaterialFlags; // bitmask HAS_* + ALPHA_MODE bits
    uint2 _pad0; // 16-byte align
}

Texture2D g_BaseColorTex;
Texture2D g_NormalTex;
Texture2D g_MetallicRoughnessTex;
Texture2D g_AOTex;
Texture2D g_EmissiveTex;
Texture2D g_HeightTex;

SamplerState g_LinearWrapSampler;

struct PSInput
{
    float4 Pos : SV_POSITION;
    float2 UV : TEXCOORD0;
    float3 WorldPos : TEXCOORD1;
    float3 WorldN : TEXCOORD2;
    float3 WorldT : TEXCOORD3;
    
    bool bFrontFace : SV_IsFrontFace;
};

struct PSOutput
{
    float4 GBuffer0 : SV_TARGET0; // Albedo.rgb, Opacity(a)
    float4 GBuffer1 : SV_TARGET1; // Normal.xyz packed (0..1)
    float4 GBuffer2 : SV_TARGET2; // Metallic, Roughness, AO, reserved
    float4 GBuffer3 : SV_TARGET3; // Emissive.rgb
};

static float3 unpackNormalTS(float3 n01)
{
    return normalize(n01 * 2.0 - 1.0);
}

static float3 packNormal01(float3 n)
{
    return n * 0.5 + 0.5;
}

void main(in PSInput PSIn, out PSOutput PSOut)
{
    float2 uv = PSIn.UV;

    // ----------------------------
    // BaseColor / Opacity
    // ----------------------------
    float4 baseColor = g_BaseColorFactor;

    if ((g_MaterialFlags & MAT_HAS_BASECOLOR) != 0)
    {
        baseColor *= g_BaseColorTex.Sample(g_LinearWrapSampler, uv);
    }

    // ----------------------------
    // Alpha Mask (cutout)
    // ----------------------------
    if (baseColor.a < g_AlphaCutoff)
        discard;
    
    // ----------------------------
    // Metallic / Roughness
    // ----------------------------
    float metallic = g_MetallicFactor;
    float roughness = g_RoughnessFactor;

    if ((g_MaterialFlags & MAT_HAS_MR) != 0)
    {
        float4 mr = g_MetallicRoughnessTex.Sample(g_LinearWrapSampler, uv);
        metallic *= mr.b; // glTF: B = metallic
        roughness *= mr.g; // glTF: G = roughness
    }

    metallic = saturate(metallic);
    roughness = saturate(roughness);

    // ----------------------------
    // AO
    // ----------------------------
    float ao = 1.0;

    if ((g_MaterialFlags & MAT_HAS_AO) != 0)
    {
        ao = g_AOTex.Sample(g_LinearWrapSampler, uv).r;
        ao = lerp(1.0, ao, g_OcclusionStrength);
    }

    // ----------------------------
    // Emissive
    // ----------------------------
    float3 emissive = g_EmissiveFactor;

    if ((g_MaterialFlags & MAT_HAS_EMISSIVE) != 0)
    {
        emissive *= g_EmissiveTex.Sample(g_LinearWrapSampler, uv).rgb;
    }

    // ----------------------------
    // Normal (World Space) - Two sided support
    // ----------------------------
    float3 N = normalize(PSIn.WorldN);
    float3 T = normalize(PSIn.WorldT);

    T = normalize(T - N * dot(N, T));
    float3 B = normalize(cross(N, T));

    if (!PSIn.bFrontFace)
    {
        N = -N;
        T = -T;
        B = -B;
    }

    if ((g_MaterialFlags & MAT_HAS_NORMAL) != 0)
    {
        float3 nTS = unpackNormalTS(g_NormalTex.Sample(g_LinearWrapSampler, uv).xyz);
        nTS.xy *= g_NormalScale;

        float3x3 TBN = float3x3(T, B, N);

        N = normalize(mul(nTS, TBN));
    }

    // ----------------------------
    // Pack to GBuffer
    // ----------------------------
    PSOut.GBuffer0 = float4(baseColor.rgb, baseColor.a);
    PSOut.GBuffer1 = float4(packNormal01(N), 1.0);
    PSOut.GBuffer2 = float4(metallic, roughness, ao, 0.0);
    PSOut.GBuffer3 = float4(emissive, 1.0);
}
