#include "HLSL_Structures.hlsli"
#include "PBRLighting.hlsli"

cbuffer FRAME_CONSTANTS
{
    FrameConstants g_FrameCB;
};
cbuffer GRASS_RENDER_CONSTANTS
{
    GrassRenderConstants g_GrassCB;
};

Texture2D<float> g_ShadowMap;
SamplerComparisonState g_ShadowCmpSampler;

struct PSInput
{
    float4 Pos : SV_Position;
    float3 PosWS : TEXCOORD0;
    float3 NormalWS : TEXCOORD1;
    float2 UV : TEXCOORD2;
    bool bFrontFace : SV_IsFrontFace;
};

static float3 WorldToShadowUVZ(float3 worldPos)
{
    float4 ls = mul(float4(worldPos, 1.0), g_FrameCB.LightViewProj);
    ls.xyz /= max(ls.w, 1e-6);

    float2 uv = ls.xy * 0.5 + 0.5;
    uv.y = 1.0 - uv.y;
    return float3(uv, ls.z);
}

float4 main(PSInput IN) : SV_TARGET0
{
    float4 baseColor4 = g_GrassCB.BaseColorFactor * g_GrassCB.Tint;

    if (g_GrassCB.AlphaCut > 0.0 && baseColor4.a < g_GrassCB.AlphaCut)
        discard;

    float3 N = normalize(IN.NormalWS);

    // IMPORTANT:
    // If you want grass to behave like deferred (which is typically single-sided),
    // do NOT flip normal by front-face.
    // If you want two-sided shading, keep this flip but accept small differences vs deferred.
    if (!IN.bFrontFace)
        N = -N;

    float3 worldPos = IN.PosWS;
    float3 V = normalize(g_FrameCB.CameraPosition - worldPos);
    float3 L = normalize(-g_FrameCB.LightDirWS);

    float NdotL = saturate(dot(N, L));

    // Shadow (match deferred: no strength-lerp, apply to direct only)
    float shadow = 1.0;
    float3 sh = WorldToShadowUVZ(worldPos);
    if (sh.x >= 0.0 && sh.x <= 1.0 && sh.y >= 0.0 && sh.y <= 1.0 && sh.z >= 0.0 && sh.z <= 1.0)
    {
        float bias = 0.0001 + (1.0 - NdotL) * 0.001;
        shadow = g_ShadowMap.SampleCmpLevelZero(g_ShadowCmpSampler, sh.xy, sh.z - bias);
    }

    // Grass material params (keep same as your intent)
    float3 baseColor = baseColor4.rgb;
    float metallic = 0.0;
    float roughness = 0.85;
    float ao = 1.0;
    float3 emissive = float3(0, 0, 0);

    float3 lit = ShadePBR_DeferredReference(
        N, V, L,
        baseColor, 
        metallic,
        roughness, 
        ao,
        emissive,
        shadow,
        g_FrameCB.LightColor, g_FrameCB.LightIntensity,
        0.65);

    return float4(lit, 1.0);
}
