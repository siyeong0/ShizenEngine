#include "HLSL_Structures.hlsli"
#include "PBRLighting.hlsli"

cbuffer FRAME_CONSTANTS
{
    FrameConstants g_FrameCB;
};

// GBuffer inputs
Texture2D<float4> g_GBuffer0; // Albedo.rgb, Opacity.a
Texture2D<float4> g_GBuffer1; // Normal packed 0..1 (world)
Texture2D<float4> g_GBuffer2; // Metallic, Roughness, AO, Reserved
Texture2D<float4> g_GBuffer3; // Emissive.rgb, unused
Texture2D<float> g_GBufferDepth; // Depth (D3D 0..1)

// Shadow map (Depth) + comparison sampler
Texture2D<float> g_ShadowMap;
SamplerComparisonState g_ShadowCmpSampler;


struct PSInput
{
    float4 Pos : SV_POSITION;
    float2 UV : TEXCOORD0;
};

// ------------------------------------------------------------
// Helpers
// ------------------------------------------------------------

static float3 UnpackNormal01(float3 n01)
{
    return normalize(n01 * 2.0 - 1.0);
}

static float3 ReconstructWorldPos(float2 uv, float depth01)
{
    float2 ndcXY = float2(uv.x * 2.0 - 1.0, (1.0 - uv.y) * 2.0 - 1.0);
    float4 ndc = float4(ndcXY, depth01, 1.0);

    float4 ws = mul(ndc, g_FrameCB.InvViewProj);
    ws.xyz /= max(ws.w, 1e-6);
    return ws.xyz;
}

static float3 WorldToShadowUVZ(float3 worldPos)
{
    float4 ls = mul(float4(worldPos, 1.0), g_FrameCB.LightViewProj);
    ls.xyz /= max(ls.w, 1e-6);

    float2 uv = ls.xy * 0.5 + 0.5;
    uv.y = 1.0 - uv.y;

    return float3(uv, ls.z);
}

static float3 ReconstructWorldRayDir(float2 uv)
{
	// NDC: xy in [-1,1], z=0(near) / 1(far) in D3D convention
    float2 ndcXY = float2(uv.x * 2.0 - 1.0, (1.0 - uv.y) * 2.0 - 1.0);

    float4 ndcNear = float4(ndcXY, 0.0, 1.0);
    float4 ndcFar = float4(ndcXY, 1.0, 1.0);

    float4 wsNear = mul(ndcNear, g_FrameCB.InvViewProj);
    float4 wsFar = mul(ndcFar, g_FrameCB.InvViewProj);

    wsNear.xyz /= max(wsNear.w, 1e-6);
    wsFar.xyz /= max(wsFar.w, 1e-6);

    return normalize(wsFar.xyz - wsNear.xyz);
}

// Main
void main(in PSInput PSIn, out float4 OutColor : SV_TARGET0)
{
    float2 uv = PSIn.UV;

    float depth01 = g_GBufferDepth.Sample(g_LinearClampSampler, uv);

	// Background / sky pixels (no geometry written to GBuffer)
    if (depth01 >= 0.999999)
    {
        float3 dirWS = ReconstructWorldRayDir(uv);
        float3 sky = g_EnvMapTex.Sample(g_LinearClampSampler, dirWS).rgb;
        OutColor = float4(sky, 1.0);
        return;
    }
	
    float4 gb0 = g_GBuffer0.Sample(g_LinearClampSampler, uv);
    float4 gb1 = g_GBuffer1.Sample(g_LinearClampSampler, uv);
    float4 gb2 = g_GBuffer2.Sample(g_LinearClampSampler, uv);
    float4 gb3 = g_GBuffer3.Sample(g_LinearClampSampler, uv);
    
    float3 baseColor = gb0.rgb;
    float opacity = gb0.a;

    float3 N = UnpackNormal01(gb1.xyz);


    float metallic = saturate(gb2.x);
    float roughness = saturate(gb2.y);
    float ao = saturate(gb2.z);

    float3 emissive = gb3.rgb;

    float3 worldPos = ReconstructWorldPos(uv, depth01);

    float3 V = normalize(g_FrameCB.CameraPosition - worldPos);
    float3 L = normalize(-g_FrameCB.LightDirWS);

    float NdotL = saturate(dot(N, L));
    float NdotV = saturate(dot(N, V));

	// Shadow
    float shadow = 1.0;
    float3 sh = WorldToShadowUVZ(worldPos);

    if (sh.x >= 0.0 && sh.x <= 1.0 && sh.y >= 0.0 && sh.y <= 1.0 && sh.z >= 0.0 && sh.z <= 1.0)
    {
        float ndl = saturate(dot(N, L));
        float bias = 0.0001 + (1.0 - ndl) * 0.001;
        shadow = g_ShadowMap.SampleCmpLevelZero(g_ShadowCmpSampler, sh.xy, sh.z - bias);
    }
    else
    {
        shadow = 1.0;
    }
	
    float3 lit = Shade(
        N, V, L, 
        baseColor, 
        metallic, 
        roughness, 
        ao, 
        emissive, 
        shadow, 
        g_FrameCB.LightColor, 
        g_FrameCB.LightIntensity, 
        0.20 /*iblScale*/);
    
    OutColor = float4(lit, opacity);
}
